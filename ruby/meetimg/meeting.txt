






on 17 november 2022 at 14:00
https://teams.live.com/meet/9417974131409




I. Ruby IDE - Integrated Development Environment - 0N LINE
  1. https://replit.com/@StefanMirchev/CoordinatedCanineConnections#main.rb
  2. https://www.onlinegdb.com/0jCJomVYn
II. 




III. Mаnual  

1.David A. Black - The Well-Grounded Rubyist, 2nd Edition - 2014.
                              Добре обоснованият рубист

2.Rails е рамка за уеб разработка (колекция от библиотеки с код и
софтуерни инструменти), който използва Ruby като свой език за програмиране. 

3.Ruby Koans
Коаните помагат с научаването на синтаксиса и структурата на Ruby, както и със запознаването с някои основни функции и библиотеки.

4. Lruby


Съдържание                                   3
Добре дошли в Малката книга на Руби          6
Научете Ruby в десет глави                   6
Какво е Ruby?                                7
Какво е Rails?                               7
Инсталиране на Ruby                          8
Ruby 1 или Ruby 2                            8
Инсталиране на Ruby Editor или IDE           9
SciTE                                        9
Komodo Edit                                  9
RubyMine                                     9
TextMate                                    10
Вземете изходния код на примерните програми 11
Стартиране на Ruby програми                 11
Стартиране на Ruby от команден ред          12
Как да използвате тази книга                14
Осмисляне на текста                         14
Глава първа                                 15
Низове и вградена оценка                    18
Методи                                      19
Числа                                       21
Тестване на условие: ако … тогава           22
Глава втора                                 24
Екземпляри и променливи на екземпляри       26
Конструктори – нови и инициализирани        28
Инспектиране на обекти                      31
Трета глава                                 35
Създаване на йерархия на класове            35
Един родител, много деца                    37
Суперкласове и подкласове                   39
Четвърта глава                              41
Методи за достъп                            41
Приписване на читатели и писатели           43
Атрибути създават променливи                46
Извикване на методи на суперклас            48
Променливи на класа                         49
Обекти „споделят“ променливи на класа       51
Глава пета                                  52
Представяне на масиви                       52
Създаване на масиви                         53
Многоизмерни масиви                         56
Итерация върху масиви                       57
Индексиране в масиви                        59
Шеста глава                                 62
Създаване на хешове                         62
Индексиране в хеш                           65
Операции за хеширане                        66
Глава седма                                 68
for loops                                   68
Block                                       72
while Loops                                 73 
While модификатори                          74
Untol Loops                                 76
Глава осма                                  78
if else                                     79
and or not                                  81
if  elsif                                   82
? :                                         83
unless                                      84
if и unless Модификатори                    84
Изявления на казуси                         86
Глава девета                                89
Модулът е като клас                         89
Методи на модула                            90
Модули като пространства от имена           91
Модул „Методи на екземпляри“                93
Включени модули или „миксини“               93
Включване на модули от файлове              97
Предварително дефинирани модули             98
Десета глава                                99
Запазване на данни                          99
YAML                                        99
Файлове                                    100
Продължавам                                101
The Little Book Of Ruby (5-то издание)     102
Още малки книги за програмиране            103

-----------------------------------------------------------------------------
Commis Waiter
https://ln5.sync.com/dl/3cd5dcc10/nsys8qh3-zxjn549t-phufdd3h-zgqbjwa3
https://ln5.sync.com/dl/2a10640a0/vkuvp6qd-8va9wm55-rzpam44c-iewf52ff

https://mega.nz/file/VlMXzZyR#siY9hmGI_jdIl9zrOPmjcw0G2cRBLDzx_6AvX5PdoxQ
https://mega.nz/file/1wVlwR4C#ORftOmgxGi2qvR8lFdy1XXXnO_rRHrpg7HmILuBvoB8



FRIENDLY SOFTWARE

4. API е съкращение на Application Programming Interface и най-просто казано позволява на програмите да си комуникират. 
5. IDE - Integrated Development Environment / Интегрираната среда за разработка - IDE обикновено се състои от редактор на код, инструменти за автоматизиране построяването на изходното приложение и дебъгер.
6. GUI - Графичен Потребителски Интерфейс
7. IoT -„Интернет на нещата“ -свързаност с устройства, които използваме в ежедневието си - хладилници, печки лампи и т.н


Commis Waiter


EVELINA
4f53paudjx1s+or9x@inbound.workablemail.com
evelina.ivanova9999@gmail.com

NEVENA
4f53paudjx1s+or9x@inbound.workablemail.com


1. Рубинени основи
Глава 1. Стартиране на вашата Ruby грамотност
Глава 2. Обекти, методи и локални променливи
Глава 3. Организиране на обекти с класове
Глава 4. Модули и програмна организация
Глава 5. Обект по подразбиране (сам), обхват и видимост
Глава 6. Техники на контролен поток
2. Вградени класове и модули
Глава 7. Основни вградени елементи
Глава 8. Низове, символи и други скаларни обекти
Глава 9. Колекция и контейнерни обекти
Глава 10. Централни колекции: Enumerable и Enumerator
Глава 11. Регулярни изрази и базирани на regexp операции с низове
Глава 12. Файлови и I/O операции
3. Рубин динамика
Глава 13. Индивидуализация на обекта
Глава 14. Извикваеми и изпълняваеми обекти
Глава 15. Обратни извиквания, кукички и интроспекция по време на изпълнение
Индекс
Списък с фигури
Списък с таблици Списък с обяви
-----------------------------------------------------------------------------



1. Рубинени основи
Глава 1. Стартиране на вашата Ruby грамотност
1.1. Основна езикова грамотност на Ruby
1.1.1. Комплект за оцеляване на Ruby синтаксис
1.1.2. Разнообразието от Ruby идентификатори
1.1.3. Извиквания на методи, съобщения и Ruby обекти
1.1.4. Писане и записване на проста програма
1.1.5. Захранване на програмата към Ruby
1.1.6. Клавиатура и файлов вход/изход
1.2. Анатомия на инсталацията Ruby
1.2.1. Поддиректорията на стандартната библиотека Ruby (RbConfig::CONFIG[rubylibdir])
1.2.2. Директорията с разширения на C (RbConfig::CONFIG[archdir])
1.2.3. site_ruby (RbConfig::CONFIG[sitedir]) и vendor_ruby
(RbConfig::CONFIG[vendordir]) директории
1.2.4. Директорията със скъпоценни камъни
1.3. Ruby разширения и програмни библиотеки
1.3.1. Зареждане на външни файлове и разширения
1.3.2. „Зареждане“ - въвеждане на файл в пътя за зареждане по подразбиране
1.3.3. „Изискване“ на функция
1.3.4. изисквам_относителен
1.4. Инструменти и приложения на Ruby извън кутията
1.4.1. Превключватели на командния ред на интерпретатора 1.4.2. Поглед отблизо на интерактивната интерпретация на Ruby с irb
1.4.3. ri и RDoc
1.4.4. Помощната програма за управление на задачите с рейк
1.4.5. Инсталиране на пакети с командата gem
1.5. Резюме
Глава 2. Обекти, методи и локални променливи
2.1. Разговор с предмети
2.1.1. Ruby и обектна ориентация
2.1.2. Създаване на общ обект
2.1.3. Методи, които приемат аргументи
2.1.4. Връщаната стойност на метод
2.2. Създаване на обект: поведението на билет
2.2.1. Обектът на билета, първо поведението
2.2.2. Запитване за обекта на билета
2.2.3. Съкращаване на кода на билета чрез интерполация на низове
2.2.4. Наличност на билети: Изразяване на булево състояние в метод
2.3. Вроденото поведение на даден обект
2.3.1. Уникално идентифициране на обекти с метода object_id
2.3.2. Запитване за способностите на обект с respond_to? метод
2.3.3. Изпращане на съобщения до обекти с метода send
2.4. Поглед отблизо на аргументите на метода
2.4.1. Задължителни и незадължителни аргументи
2.4.2. Стойности по подразбиране за аргументи
2.4.3. Ред на параметрите и аргументите
2.4.4. Какво не можете да правите в списъците с аргументи
2.5. Локални променливи и присвояване на променливи
2.5.1. Променливи, обекти и препратки
2.5.2. Препратки при присвояване и преназначаване на променливи
2.5.3. Препратки и аргументи на метода
2.5.4. Локални променливи и нещата, които изглеждат като тях
2.6. РезюмеГлава 3. Организиране на обекти с класове
3.1. Класове и екземпляри
3.1.1. Методи за екземпляри
3.1.2. Методи за отмяна
3.1.3. Повторно отваряне на класове
3.2. Променливи на екземпляр и състояние на обект
3.2.1. Инициализиране на обект със състояние
3.3. Методи за настройка
3.3.1. Знакът за равенство (=) в имената на методите
3.3.2. Синтактична захар за подобни на присвояване методи
3.3.3. Отприщени методи на сетер
3.4. Атрибути и семейството на методите attr_*
3.4.1. Автоматизиране на създаването на атрибути
3.4.2. Обобщение на методите attr_*
3.5. Наследяване и йерархия на класове Ruby
3.5.1. Единично наследяване: Едно към клиент
3.5.2. Произход на обекта и не толкова липсващата връзка: класът Object
3.5.3. По-големият брат на El Viejo: BasicObject
3.6. Класове като обекти и приемници на съобщения
3.6.1. Създаване на класови обекти
3.6.2. Как обектите на класа извикват методи
3.6.3. Единичен метод с всяко друго име.
3.6.4. Кога и защо да напиша метод на клас
3.6.5. Методи на клас срещу методи на екземпляри
3.7. Константи отблизо
3.7.1. Основно използване на константи
3.7.2. Преназначаване срещу модифициране на константи
3.8. Природа срещу възпитание в Ruby обекти
3.9. Резюме
Глава 4. Модули и програмна организация
4.1. Основи на създаването и използването на модула4.1.1. Модул, капсулиращ „подобие на стек“
4.1.2. Смесване на модул в клас
4.1.3. По-нататъшно използване на модула
4.2. Модули, класове и търсене на метод
4.2.1. Илюстриране на основите на търсенето на метод
4.2.2. Дефиниране на един и същи метод повече от веднъж
4.2.3. Как работи prepend
4.2.4. Правилата за търсене на метод са обобщени
4.2.5. Отиване нагоре по пътя за търсене на метод със super
4.3. Методът method_missing
4.3.1. Комбиниране на method_missing и super
4.4. Дизайн и именуване на клас/модул
4.4.1. Смесване и/или наследяване
4.4.2. Вложени модули и класове
4.5. Резюме
Глава 5. Обект по подразбиране (сам), обхват и видимост
5.1. Разбиране на себе си, текущия/обект по подразбиране
5.1.1. Кой може да бъде себе си и къде
5.1.2. Аз-обектът от най-високо ниво
5.1.3. Самостоятелно вътре в дефинициите на клас, модул и метод
5.1.4. Себе си като получател по подразбиране на съобщения
5.1.5. Разрешаване на променливи на екземпляр чрез себе си
5.2. Определяне на обхвата
5.2.1. Глобален обхват и глобални променливи
5.2.2. Местен обхват
5.2.3. Взаимодействието между локалния обхват и себе си
5.2.4. Обхват и резолюция на константите
5.2.5. Синтаксис, обхват и видимост на променливата на класа
5.3. Разполагане на правила за достъп до метод
5.3.1. Частни методи
5.3.2. Защитени методи5.4. Писане и използване на методи от най-високо ниво
5.4.1. Дефиниране на метод от най-високо ниво
5.4.2. Предварително дефинирани (вградени) методи от най-високо ниво
5.5. Резюме
Глава 6. Техники на контролен поток
6.1. Условно изпълнение на код
6.1.1. Ключовата дума if и приятели
6.1.2. Синтаксис на присвояване в тела на условия и тестове
6.1.3. казуси
6.2. Повтарящи се действия с цикли
6.2.1. Безусловен цикъл с метода на цикъла
6.2.2. Условен цикъл с ключовите думи while и until
6.2.3. Зацикляне въз основа на списък със стойности
6.3. Итератори и кодови блокове
6.3.1. Съставките на итерацията
6.3.2. Итерация, домашен стил
6.3.3. Анатомията на извикване на метод
6.3.4. Къдрави скоби срещу do/end в синтаксиса на кодовия блок
6.3.5. Време за внедряване
6.3.6. Важността да бъдеш всеки
6.3.7. От всяка карта
6.3.8. Параметри на блока и обхват на променливи
6.4. Обработка на грешки и изключения
6.4.1. Повишаване и спасяване на изключения
6.4.2. Спасителната ключова дума за спасяването!
6.4.3. Изрично повдигане на изключения
6.4.4. Прихващане на изключение в спасителна клауза
6.4.5. Гарантиращата клауза
6.4.6. Създаване на ваши собствени класове изключения
6.5. Резюме
2. Вградени класове и модули
Глава 7. Основни вградени елементи7.1. Литералните конструктори на Ruby
7.2. Повтаряща се синтактична захар
7.2.1. Дефиниране на оператори чрез дефиниране на методи
7.2.2. Персонализиране на унарни оператори
7.3. Банг (!) методи и „опасност“
7.3.1. Разрушителни (променящи приемника) ефекти като опасност
7.3.2. Разрушителността и „опасността“ варират независимо
7.4. Вградени и персонализирани методи за_* (преобразуване).
7.4.1. Преобразуване на низ: към_s
7.4.2. Преобразуване на масив с to_a и оператор *
7.4.3. Числено преобразуване с to_i и to_f
7.4.4. Ролева игра до_* методи
7.5. Булеви състояния, булеви обекти и нула
7.5.1. Вярно и невярно като състояния
7.5.2. истинно и невярно като обекти
7.5.3. Специалният обект нула
7.6. Сравняване на два обекта
7.6.1. Тестове за равенство
7.6.2. Сравнения и модул Comparable
7.7. Проверка на възможностите на обекта
7.7.1. Изброяване на методите на обект
7.7.2. Запитване към обекти на клас и модул
7.7.3. Списъци с филтрирани и избрани методи
7.8. Резюме
Глава 8. Низове, символи и други скаларни обекти
8.1. Работа със струни
8.1.1. Низова нотация
8.1.2. Основна манипулация на низове
8.1.3. Запитващи низове
8.1.4. Сравнение и подреждане на низове
8.1.5. Трансформация на низове 8.1.6. Конверсии на низове
8.1.7. Кодиране на низове: Кратко въведение
8.2. Символи и тяхното използване
8.2.1. Основни характеристики на символите
8.2.2. Символи и идентификатори
8.2.3. Символи на практика
8.2.4. Низове и символи в сравнение
8.3. Числови обекти
8.3.1. Числени класове
8.3.2. Извършване на аритметични операции
8.4. Часове и дати
8.4.1. Създаване на обекти за дата/час
8.4.2. Методи за търсене на дата/час
8.4.3. Методи за форматиране на дата/час
8.4.4. Методи за преобразуване на дата/час
8.5. Резюме
Глава 9. Колекция и контейнерни обекти
9.1. Масиви и хешове в сравнение
9.2. Работа с колекции с масиви
9.2.1. Създаване на нов масив
9.2.2. Вмъкване, извличане и премахване на елементи от масив
9.2.3. Комбиниране на масиви с други масиви
9.2.4. Трансформации на масиви
9.2.5. Масивно запитване
9.3. Хешове
9.3.1. Създаване на нов хеш
9.3.2. Вмъкване, извличане и премахване на хеш двойки
9.3.3. Задаване на хеш стойности и поведение по подразбиране
9.3.4. Комбиниране на хешове с други хешове
9.3.5. Хеш трансформации
9.3.6. Хеш запитване
9.3.7. Хешовете като крайни аргументи на метода9.3.8. Заобикаляне обратно към синтаксиса на аргументите: Наименувани (ключови) аргументи
9.4. Диапазони
9.4.1. Създаване на диапазон
9.4.2. Логика за включване на обхват
9.5. Комплекти
9.5.1. Създаване на комплект
9.5.2. Манипулиране на елементи от набора
9.5.3. Подмножества и супермножества
9.6. Резюме
Глава 10. Централни колекции: Enumerable и Enumerator
10.1. Получаване на изброимост чрез всеки
10.2. Изброими булеви заявки
10.3. Изброимо търсене и избиране
10.3.1. Получаване на първото съвпадение с find
10.3.2. Получаване на всички съвпадения с find_all (a.k.a. select) и отхвърляне
10.3.3. Избиране на съвпадения на threequal с grep
10.3.4. Организиране на резултатите от селекцията с group_by и partition
10.4. Поелементно изброими операции
10.4.1. Първият метод
10.4.2. Методите вземане и пускане
10.4.3. Методите min и max
10.5. Роднини на всеки
10.5.1. reverse_each
10.5.2. Методът each_with_index (и each.with_index)
10.5.3. Методите each_slice и each_cons
10.5.4. Методът на цикъла
10.5.5. Изброимо намаление с инжектиране
10.6. Методът на картата
10.6.1. Върнатата стойност на map
10.6.2. Картографиране на място с карта!
10.7. Низове като квазиизброими 10.8. Сортиране на изброими
10.8.1. Когато модулът Comparable се вписва в изброимо сортиране (или не)
10.8.2. Дефиниране на логика за сортиране с блок
10.8.3. Кратко сортиране с sort_by
10.9. Изброителите и следващото измерение на изброимостта
10.9.1. Създаване на изброители с кодов блок
10.9.2. Прикрепване на преброители към други обекти
10.9.3. Неявно създаване на изброители чрез извиквания на итератор без блокове
10.10. Семантика и употреби на изброител
10.10.1. Как да използвате всеки метод на изброител
10.10.2. Защита на обекти с преброители
10.10.3. Фина итерация с изброители
10.10.4. Добавяне на изброимост с изброител
10.11. Верига на метода на изброителя
10.11.1. Икономия на междинни обекти
10.11.2. Индексиране на изброими елементи с with_index
10.11.3. Изключителни или операции върху низове с изброители
10.12. Мързеливи преброители
10.12.1. FizzBuzz с мързелив изброител
10.13. Резюме
Глава 11. Регулярни изрази и базирани на regexp операции с низове
11.1. Какво представляват регулярните изрази?
11.2. Писане на регулярни изрази
11.2.1. Виждане на модели
11.2.2. Просто съпоставяне с буквални регулярни изрази
11.3. Изграждане на шаблон в регулярен израз
11.3.1. Буквални знаци в шаблони
11.3.2. Заместващият символ точка (.)
11.3.3. Класове на знаци
11.4. Съвпадение, улавяне на поднизове и MatchData
11.4.1. Прихващане на подсъответствия със скоби 11.4.2. Съчетайте успех и провал
11.4.3. Два начина за получаване на улавяне
11.4.4. Друга информация за MatchData
11.5. Фина настройка на регулярни изрази с квантори, котви и модификатори
11.5.1. Ограничаващи съвпадения с квантори
11.5.2. Алчни (и не-алчни) квантификатори
11.5.3. Котви и твърдения за регулярен израз
11.5.4. Модификатори
11.6. Преобразуване на низове и регулярни изрази един в друг
11.6.1. Идиоми от низ към регулярен израз
11.6.2. Преминаване от регулярен израз към низ
11.7. Често срещани методи, които използват регулярни изрази
11.7.1. Низ #сканиране
11.7.2. Низ #разделяне
11.7.3. под/под! и gsub/gsub!
11.7.4. Равенство между главни и малки букви и grep
11.8. Резюме
Глава 12. Файлови и I/O операции
12.1. Как се сглобява I/O системата на Ruby
12.1.1. Класът IO
12.1.2. IO обекти като изброими
12.1.3. STDIN, STDOUT, STDERR
12.1.4. Малко повече за въвеждането от клавиатурата
12.2. Основни операции с файлове
12.2.1. Основи на четене от файлове
12.2.2. Редовно четене на файлове
12.2.3. Байтово и символно четене на файлове
12.2.4. Търсене и заявка за позиция на файла
12.2.5. Четене на файлове с методи на клас File
12.2.6. Писане във файлове
12.2.7. Използване на блокове за обхват на файлови операции
12.2.8. Изброимост на файлове 12.2.9. Файлови I/O изключения и грешки
12.3. Запитване за IO и File обекти
12.3.1. Получаване на информация от класа File и модула FileTest
12.3.2. Извличане на файлова информация с File::Stat
12.4. Манипулиране на директория с класа Dir
12.4.1. Четене на записи в директория
12.4.2. Манипулиране на директории и заявки
12.5. Файлови инструменти от стандартната библиотека
12.5.1. Модулът FileUtils
12.5.2. Класът Pathname
12.5.3. Класът StringIO
12.5.4. Open-uri библиотеката
12.6. Резюме
3. Рубин динамика
Глава 13. Индивидуализация на обекта
13.1. Къде са методите сингълтън: Класът сингълтън
13.1.1. Двойно определяне чрез единични класове
13.1.2. Директно изследване и модифициране на единичен клас
13.1.3. Единични класове по пътя за търсене на метод
13.1.4. Методът singleton_class
13.1.5. Методи на клас в (още повече) дълбочина
13.2. Модифициране на основните класове и модули на Ruby
13.2.1. Рисковете от промяна на основната функционалност
13.2.2. Адитивни промени
13.2.3. Преминаване през
13.2.4. Промени по обект с разширение
13.2.5. Използване на уточнения за повлияване на основното поведение
13.3. BasicObject като предшественик и клас
13.3.1. Използване на BasicObject
13.3.2. Внедряване на подклас на BasicObject
13.4. ОбобщениеГлава 14. Извикваеми и изпълняваеми обекти
14.1. Основни анонимни функции: Класът Proc
14.1.1. Proc обекти
14.1.2. Процеси и блокове и как се различават
14.1.3. Block-proc конверсии
14.1.4. Използване на Symbol#to_proc за краткост
14.1.5. Процеси като затваряния
14.1.6. Параметри и аргументи на Proc
14.2. Създаване на функции с ламбда и ->
Конструкторът “stabby lambda”, ->
14.3. Методите като обекти
14.3.1. Прихващане на обекти на метода
14.3.2. Обосновката на методите като обекти
14.4. Семейството от методи eval
14.4.1. Изпълнение на произволни низове като код с eval
14.4.2. Опасностите от eval
14.4.3. Методът instance_eval
14.4.4. Използване на class_eval (a.k.a. module_eval)
14.5. Паралелно изпълнение с нишки
14.5.1. Убиване, спиране и стартиране на нишки
14.5.2. Сървър за дати с резба
14.5.3. Писане на чат сървър с помощта на сокети и нишки
14.5.4. Нишки и променливи
14.5.5. Манипулиране на ключове за нишки
14.6. Издаване на системни команди от вътрешността на Ruby програмите
14.6.1. Системният метод и обратните точки
14.6.2. Комуникация с програми чрез open и popen3
14.7. Резюме
Глава 15. Обратни извиквания, кукички и интроспекция по време на изпълнение
15.1. Обратни извиквания и кукички
15.1.1. Прихващане на неразпознати съобщения с method_missing15.1.2. Прихващането включва и предхожда операции
15.1.3. Прихващане разширяване
15.1.4. Прихващане на наследяване с Class#inherited
15.1.5. Методът Module#const_missing
15.1.6. Методите method_added и singleton_method_added
15.2. Интерпретиране на заявки за възможностите на обекта
15.2.1. Изброяване на нечастни методи на обект
15.2.2. Изброяване на частни и защитени методи
15.2.3. Получаване на методи за екземпляри на клас и модул
15.2.4. Изброяване на сингълтън методи на обекти
15.3. Интроспекция на променливи и константи
15.3.1. Изброяване на локални и глобални променливи
15.3.2. Изброяване на променливи на екземпляр
15.4. Проследяване на изпълнението
15.4.1. Проучване на проследяването на стека с повикващия
15.4.2. Писане на инструмент за анализиране на следи на стекове
15.5. Обратни извиквания и проверка на метода на практика
15.5.1. Фон на MicroTest: MiniTest
15.5.2. Специфициране и внедряване на MicroTest
15.6. Резюме
Индекс
Списък с фигури
Списък с таблици
Списък с обяви


Hi Evelina,
For today's meeting at 10:00AM, I am ready to talk with three devices Linux, Windows and Android. via Google Messing with code jbz-mxce-dhu. I hope there will be no problems. Have a Nice day!

Kind Regards
Stefan
